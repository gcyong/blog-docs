# 한글 인코딩 1

이전 글에서 인코딩에 대해 말씀드린 적이 있습니다.

2018년 10월 21일 - [문자 부호화(Character encoding)](https://gcyong.tistory.com/137)

상기한 링크를 타고 들어가면 정말 읽기도 싫을 정도로 긴 스크롤을 자랑하고 있습니다. 인코딩에 대해 이것저것 알아보다 정리한 내용을 검토없이(?!) 그대로 업로드 했는데요, 제가 봐도 이건 아니다 싶어 많은 분들께서 궁금해 하실법한 내용만 간추려서 정리했습니다. 글 제목을 "한글 인코딩" 이라고 지은 이유도, 광범위한 "문자 부호화"에서 주로 관심있어 하는 내용은 아무래도 한글을 처리하는 방법이라 판단했기 때문입니다.

거기에 도움이 될 법한 시각적 자료와 구현 예제까지 더하여 내용을 이해하는데 도움을 드리고자 합니다. 그리고 상기한 링크에서는 두서없이 나열했다면 이번 글에서는 틀린 내용은 없는지 꼼꼼히 살펴보면서 최대한 정확하게 말씀드리고 싶습니다. 그래도 부분적으로 틀린 내용이 있을 경우 코멘트 부탁드리겠습니다.

# 조합형 vs 완성형

대체로 한글 인코딩에 대한 글은 문자에 대한 기본 정의, 또는 한글 부호화의 시초라고 할 수 있는 KS C 5601에 대한 소개부터 나오곤 합니다. 하지만 여기서는 비교적 간단하게 정리할 수 있는 조합형과 완성형에 대한 소개부터 시작하고자 합니다.

## 조합형과 완성형

조합형은 한글의 자모를 조합하여 글자를 만드는 방법을 말합니다. 가령, '흙'이라는 글자는 초성 'ㅎ', 중성 'ㅡ', 종성 'ㄺ'으로 이루어진 글자입니다. 이 때, 조합형으로 '흙'을 표현한다면 'ㅎ', 'ㅡ', 'ㄺ'에 각각 값을(코드를) 부여하고, 각 코드를 나열하면서 '흙'을 조립하면 됩니다. 조합형의 장단점은 다음과 같습니다.

 * 장점
    1. 적은 수의 한글 자모만으로도 모든 글자를 표현할 수 있습니다.
    2. 글자를 만드는 과정이 한글 창제 원리에 부합하며 직관적입니다.
 * 단점
    1. 글자를 조합하여 글자 하나에 대한 코드를 구성하므로 비교적 복잡합니다.
    2. 종성이 있는 경우와 없는 경우에 따라 하나의 글자를 표현하는 데 필요한 비트 길이가 다릅니다. (아무래도 종성이 있는 경우 더 긴 비트열이 필요합니다.)

단점 2번의 경우 초성, 중성, 종성 각각에 필요한 비트를 고정적으로 할당하면 될 것 같지만, 이 때는 불필요한 비트 열이 사용되어 낭비되는 공간이 존재할 수 있습니다.

한편, 완성형은 초성+중성 또는 초성+중성+종성 꼴로 이루어진, 한글 자모가 이미 조립된 글자에 코드를 부여하는 방식입니다. 가령, '흙'이라는 글자는 그 자체로 대응되는 값을(코드를) 가지고 있으며, 이 코드를 나타내기만 하면 '흙'을 표현할 수 있습니다. 완성형의 장단점은 다음과 같습니다.

 * 장점
    1. 문자 표기 방식이 비교적 간단합니다. 대부분 한글 글자 하나는 자음과 모음을 따로 보지 않고 이들이 조립된 글자를 의미하는데, 완성형은 이 조립된 글자 하나에 코드를 부여하기 때문입니다.
    2. 고정된 비트 길이 안에 표현하려는 글자를 대응시킬 수 있습니다.
 * 단점
    1. 표현하려는 문자에 대해 일일히 코드를 대응시켜야 합니다. 다시말해, 코드를 부여받지 못한 글자는 표기할 수 없습니다.
    2. 글자의 기본 구성인 초성, 중성, 종성을 조합하여 글자를 만드는 관점에서 보았을 때는 (조립하는 것이 아닌) 이미 조립된 글자에 하나씩 코드를 대입하므로 기본 원칙(원리)에 부합하지 못하고 직관적이지 못합니다.

## 과연 누가 승자인가?

한쪽의 장점이 다른 한쪽의 단점이 되는 두 방법은 우열을 가리기 힘들 것 같지만, 생각보다 답은 간단합니다. 과거부터 **완성형**이 조합형보다 널리 쓰였습니다. 두 방법 모두 나름의 강점이 있지만, 조합형 보다는 완성형이 더 현실적인 장점에 가깝습니다. 조합형의 장점을 다시 보자면,

 1. 적은 수의 한글 자모만으로도 모든 글자를 표현할 수 있습니다.
 2. 글자를 만드는 과정이 한글 창제 원리에 부합하며 직관적입니다.

인데, 1번의 경우 굳이 모든 글자를 표현할 필요는 없다는 점에서 장점만은 아닙니다. 컴퓨터에서 사용하는 글자는 제한되어 있는데, 아무래도 '가' 라는 글자가 '갏' 이라는 글자보다 많이 쓰이는 것은 경험적으로 알 수 있습니다. 따라서 국립국어원에서나 쓸 법한 '갏' 글자를 지원하기 위해 조합형의 단점을 안을 필요는 없습니다.

한편, 글자를 화면이나 프린터에 출력하기 위해서는 글꼴이 필요합니다. 그리고 결과적으로 글꼴에 사용하려는 글자가 없으면 출력이 되지 않습니다. 가령, 네이버에서 제공하는 나눔스퀘어 글꼴은 (한글만인지 모르겠지만) 많이 쓰이는 2350자만 제공하고 있습니다. 이 때, 2350자 내에 속해있지 않은 글자는 입력해도 글자가 보이지 않습니다.

[네이버 한글한글아름답게](https://hangeul.naver.com/2017/nanum)

적어도 한글의 자모를 조합했을 때 2350자는 훌쩍 넘어버리니, 모든 한글을 '나눔스퀘어' 글꼴로 표현하는 것은 불가능합니다.

2번의 경우는 직관적이라는 장점이 있지만, 직관적인 것은 어디까지나 사람의 관점에서 보는 것입니다. 컴퓨터 구조적으로 처리하기 편리하다는 점에서의 직관은 아니기 때문에 이것 역시 장점이라고 보기에는 어렵습니다. 한글 창제 원리가 우연히 부호화를 처리하는 원리와 비슷하다면 큰 강점이겠지만, 그런 것도 아니어서 한글 부호화에 있어 이득인 것도 아닙니다.

반면, 완성형의 장점은 실제 문자를 처리하는 데 있어 현실적인 장점에 속해 있습니다. 완성형의 장점도 다시 나열해보면 다음과 같습니다.

 1. 문자 표기 방식이 비교적 간단합니다. 대부분 한글 글자 하나는 자음과 모음을 따로 보지 않고 이들이 조립된 글자를 의미하는데, 완성형은 이 조립된 글자 하나에 코드를 부여하기 때문입니다.
 2. 고정된 비트 길이 안에 표현하려는 글자를 대응시킬 수 있습니다.

우리가 처리하는 대부분의 글자 하나는 자모가 결합된 모습입니다. 즉, 초성+중성 내지 초성+중성+종성 꼴로 이루어진 글자를 부호화 하는 데 의미가 있습니다. 'ㄱ'과 'ㅏ'와 같은 낱개의 자모는 글자를 이루는 데 중요한 기호이지만, 결국 이를 합친 글자인 '가'라는 글자가 현실적으로 우리가 처리할 글자 단위가 되는 것입니다. 그렇다면, 'ㄱ'과 'ㅏ'에 일일히 코드를 부여하고 조립하는 것 보다는 '가' 자체에 하나의 코드를 부여하는 것이 현실적이 되는 것이고, 결국 이는 완성형의 장점 1번과 맞아 떨어집니다.

한편, 오래전 표준으로 제정된 ASCII (American Standard Code for Interface Interchange; 미국정보교환표준부호)에서는 숫자, 특수문자, 제어문자, 영문자 알파벳 'A'부터 'z'까지 등 7비트 범위 내에서 표현할 수 있도록 각 문자에 대해 하나씩 코드를 부여하고 있습니다.

영문자야 몇 개 되지 않을 뿐만 아니라 한글 처럼 단위가 되는 글자를 조합한 형태도 아니니 하니씩 대응시키는 것이 무조건 이득입니다. 몇 안되는 글자에 코드를 부여하는 것이 (적어도 영문자에서는) 직관적이고 처리하기도 편했는지, 이전부터 많은 컴퓨터 기종에서 ASCII가 문자 처리를 하는 사실상의 표준이 되었습니다. 이 때문에, 이후 설계되는 문자 부호화 표준은 ASCII를 결코 무시할 수 없었습니다. (심지어 비교적 최근에 표준화 되었던 (그리고 지금도 업데이트 중인) 유니코드 역시 ASCII 영역에서 표현할 수 있는 글자는 ASCII 코드 값으로 그대로 표기합니다.)

한글 부호화 표준 역시 마찬가지로, ASCII를 감안하여 표준을 만들어야 하니 전혀 새로운 방식의 조합형 보다는 (ASCII와 마찬가지로) 글자 하나에 코드를 하나 부여하는 완성형이 더 어울렸습니다. 이러한 완성형의 장점은 2번에 속하며, 가장 현실적인 장점이 아닌가 싶습니다.

ASCII가 나와서 하는 말입니다만, 1바이트는 '흔히' 8비트 입니다. 따라서 ASCII를 (8비트를 1바이트로 쳐주는 대부분의) 컴퓨터로 처리하면 1비트가 남는데, 이 1비트는 경우에 따라 패리디 비트(데이터 점검 비트)로 쓰이거나 라틴 문자까지 대응시켜 확장합니다. (흔히 후자의 경우를 Extended ASCII라고 합니다.)

제가 조합형과 완성형을 비교하면서 '현실적' 이라던가, '경험적' 이라는 단어를 쓰면서 완성형에 무게를 싣고 말씀 드렸습니다. 이런 기조로 말씀드린 이유는 한글 부호화 표준인 'KS C 5601'이나, 이 표준을 개정한 'KS X 1001' 표준은 모두 '산업화' 표준이기 때문입니다. 한글 부호화에 대한 산업화 표준은 '얼마나 한글을 완벽하게 표현할 수 있을까'가 아닌, '산업 현장에서 필요한 한글을 얼만큼 표현할 수 있을까' 에 대해 반영한 것입니다.

이런 물음에 대한 결과, 산업 현장에 놓인 기계(컴퓨터)는 기계 구조성 조합형보다 완성형이 낫다고 판단했으며, 모든 문자를 표현할 수 없다는 한계에 대해서는 각종 신문, 문학 및 전문 서적 등을 참고하여 최대한 많이 쓰는 문자를 통계 내어 해결하려고 노력했습니다. 또한, 글자를 인쇄하고 전산으로 처리하는 곳에서는 한글 뿐만 아니라 영문, 숫자 등을 사용했었고, 영문, 숫자는 특히 ASCII 코드 값을 사용했으므로 KS C 5601이나 KS X 1001에서 `0`부터 `7F`(하위 7비트가 모두 `1`)는 ASCII를 호환하기 위해 마련되었습니다. (완벽히 ASCII와 동일하지는 않습니다. 가령, ASCII의 역실래시 기호에 대응돤 코드는 한글 부호화 표준에서 한국 통화 기호와 대응됩니다.)

그리고 이러한 산업 현장에서는 한글 뿐만 아니라 한자나 히라가나, 가타카나까지 요구하게 되어서, 나중에 보시겠지만 KS C 5601이나 KS X 1001에서는 한글 뿐만 아니라 한자 및 가나(히라가나 가타카나) 문자까지 포함되었습니다. 만일 한글에만 초점을 맞추어 보다 많은 한글을 대응하고 싶었으면 이런 문자보다는 한글을 대응했어야 맞습니다. 하지만 상기했듯이, 우리가 한글을 전산으로 처리하고 싶어 만든 표준은 '완벽한 한글의 부호화'를 목적으로 두지 않았습니다.